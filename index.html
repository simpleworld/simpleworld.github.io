<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>PHANTOM OPS: WEAPONRY & SKINS</title>
    <style>
        :root { --main: #ff9d00; --bg: #0b0b0b; --glass: rgba(15, 15, 15, 0.95); --red: #ff3333; }
        * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
        body { margin: 0; overflow: hidden; background: #000; color: white; }
        
        /* UI LAYERS */
        #game-layer { position: absolute; inset: 0; z-index: 1; }
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
        .interactive { pointer-events: auto; }

        /* HUD */
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: var(--main); border-radius: 50%;
            box-shadow: 0 0 4px var(--main); transition: 0.1s;
        }
        #crosshair.spread { width: 20px; height: 20px; background: transparent; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; }
        
        #hud-bottom {
            position: absolute; bottom: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .hud-panel {
            background: linear-gradient(90deg, rgba(0,0,0,0.8), transparent);
            padding: 15px 30px; border-left: 4px solid var(--main);
        }
        .hp-val { font-size: 40px; font-weight: 900; }
        .ammo-val { font-size: 40px; font-weight: 900; text-align: right; }
        .sub-text { color: #888; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
        
        #killfeed { position: absolute; top: 20px; right: 20px; text-align: right; font-weight: bold; font-size: 14px; }
        .kill-msg { margin-bottom: 5px; color: var(--red); text-shadow: 1px 1px 0 #000; animation: fadeOut 4s forwards; }
        @keyframes fadeOut { 0% {opacity:1} 80% {opacity:1} 100% {opacity:0} }

        /* MENUS */
        .menu-screen {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .hidden { display: none !important; }

        h1 { font-size: 60px; margin: 0; color: var(--main); text-shadow: 0 0 20px var(--main); font-style: italic; }
        
        .btn {
            background: transparent; border: 2px solid #444; color: white;
            padding: 15px 40px; font-size: 18px; margin: 10px; cursor: pointer;
            transition: 0.2s; min-width: 200px; text-transform: uppercase; font-weight: bold;
        }
        .btn:hover { border-color: var(--main); background: rgba(255, 157, 0, 0.1); transform: skewX(-10deg); }
        
        /* SKINS SHOP */
        #skins-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            margin-top: 30px; max-width: 900px; max-height: 60vh; overflow-y: auto;
        }
        .skin-card {
            background: rgba(255,255,255,0.05); border: 1px solid #333; padding: 15px;
            text-align: center; cursor: pointer; transition: 0.2s; position: relative;
        }
        .skin-card:hover { border-color: var(--main); background: rgba(255,255,255,0.1); }
        .skin-card.active { border-color: #0f0; box-shadow: 0 0 15px rgba(0,255,0,0.2); }
        .rarity { position: absolute; top: 5px; right: 5px; font-size: 10px; padding: 2px 5px; background: #333; }
        .rarity.common { color: #fff; }
        .rarity.rare { color: #00aaff; }
        .rarity.legendary { color: #ffaa00; }
        .price-tag { color: #0f0; font-weight: bold; margin-top: 5px; }

        #balance-display { position: absolute; top: 20px; left: 20px; font-size: 24px; color: gold; font-weight: bold; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="game-hud" class="hidden">
            <div id="crosshair"></div>
            <div id="killfeed"></div>
            <div id="hud-bottom">
                <div class="hud-panel">
                    <div class="hp-val">100</div>
                    <div class="sub-text">Health</div>
                </div>
                <div class="hud-panel">
                    <div class="ammo-val" id="ammo-text">30 / 90</div>
                    <div class="sub-text" id="weapon-name">AK-47</div>
                </div>
            </div>
        </div>

        <div id="lobby-screen" class="menu-screen interactive">
            <h1>PHANTOM OPS</h1>
            <div style="margin-bottom: 20px; color: #888;">ADVANCED WEAPONRY SYSTEM</div>
            <button class="btn" onclick="Game.start()">DEPLOY</button>
            <button class="btn" onclick="Menu.openSkins()">ARMORY & SKINS</button>
            <button class="btn" onclick="alert('Controls: WASD, Space, 1/2/3, R, LMB')">CONTROLS</button>
        </div>

        <div id="skins-screen" class="menu-screen interactive hidden">
            <h2 style="color: white; border-bottom: 2px solid var(--main);">ARMORY</h2>
            <div id="balance-display">BALANCE: $0</div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button class="btn" style="min-width: 100px; padding: 10px;" onclick="Menu.filterSkins('awp')">AWP</button>
                <button class="btn" style="min-width: 100px; padding: 10px;" onclick="Menu.filterSkins('glock')">GLOCK</button>
                <button class="btn" style="min-width: 100px; padding: 10px;" onclick="Menu.filterSkins('knife')">KNIFE</button>
            </div>

            <div id="skins-grid">
                </div>
            <button class="btn" style="margin-top: 20px;" onclick="Menu.closeSkins()">BACK</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            fov: 75,
            sens: 0.002,
            gravity: 25.0,
            speed: 12.0,
            botCount: 8
        };

        // --- GLOBAL STATE ---
        const State = {
            money: 1000,
            inventory: {
                awp: 'default',
                glock: 'default',
                knife: 'default'
            },
            ownedSkins: ['awp_default', 'glock_default', 'knife_default'],
            currentWeapon: 'glock', // 'awp', 'glock', 'knife'
            isPlaying: false
        };

        // --- DATA: SKINS ---
        const SKINS_DB = {
            awp: [
                { id: 'awp_default', name: 'Factory Issue', price: 0, rarity: 'common', color: 0x333333, roughness: 0.5 },
                { id: 'awp_asiimov', name: 'Sci-Fi Orange', price: 500, rarity: 'legendary', color: 0xff6600, roughness: 0.2 },
                { id: 'awp_dragon', name: 'Emerald Dragon', price: 1200, rarity: 'legendary', color: 0x004400, em: 0x00ff00, roughness: 0.1 }
            ],
            glock: [
                { id: 'glock_default', name: 'Standard', price: 0, rarity: 'common', color: 0x111111 },
                { id: 'glock_fade', name: 'Fade', price: 300, rarity: 'rare', color: 0x550055, em: 0x220022 },
                { id: 'glock_gold', name: 'Golden Era', price: 800, rarity: 'legendary', color: 0xffcc00, metal: 1.0, roughness: 0.1 }
            ],
            knife: [
                { id: 'knife_default', name: 'Tactical', price: 0, rarity: 'common', color: 0x444444 },
                { id: 'knife_ruby', name: 'Ruby Doppler', price: 1000, rarity: 'legendary', color: 0xaa0000, em: 0x550000, metal: 1.0 },
                { id: 'knife_blue', name: 'Sapphire', price: 1000, rarity: 'legendary', color: 0x0000aa, em: 0x000055, metal: 1.0 }
            ]
        };

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer, controls;
        let raycaster = new THREE.Raycaster();
        
        // Groups
        let weaponRig; // Holds arms + weapon
        let currentWeaponMesh;
        const objects = []; // Shootable stuff
        const bots = [];
        const particles = [];

        // Physics vars
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let canJump = false;

        // Weapon Mechanics
        let isFiring = false;
        let lastFireTime = 0;
        let recoilPitch = 0; // Camera X rotation offset
        let recoilZ = 0; // Weapon kickback
        let sway = { x: 0, y: 0 };
        
        // --- INITIALIZATION ---
        init();
        loadState();
        animate();

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0b0b0b);
            scene.fog = new THREE.Fog(0x0b0b0b, 0, 60);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.prepend(renderer.domElement);

            // 4. Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Controls
            controls = new PointerLockControls(camera, document.body);
            controls.addEventListener('unlock', () => {
                if(State.isPlaying) {
                    // Simple pause logic could go here
                }
            });

            // 6. Map Generation
            generateMap();

            // 7. Weapon Rig (The Hands)
            setupWeaponRig();

            // 8. Event Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', () => { if(State.isPlaying && controls.isLocked) isFiring = true; });
            document.addEventListener('mouseup', () => isFiring = false);
            
            // Generate Bots
            spawnBots(CONFIG.botCount);
        }

        // --- MAP GENERATION ---
        function generateMap() {
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 })
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);
            objects.push(floor);

            // Walls / Boxes
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            const mats = [
                new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.1 }), // Concrete
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })  // Wood crates
            ];

            for(let i=0; i<80; i++) {
                const w = 2 + Math.random()*5;
                const h = 2 + Math.random()*8;
                const d = 2 + Math.random()*5;
                const mesh = new THREE.Mesh(boxGeo, mats[Math.floor(Math.random()*2)]);
                
                mesh.position.x = (Math.random()-0.5) * 120;
                mesh.position.z = (Math.random()-0.5) * 120;
                mesh.position.y = h/2;
                
                // Clear spawn area
                if(Math.abs(mesh.position.x) < 10 && Math.abs(mesh.position.z) < 10) continue;

                mesh.scale.set(w,h,d);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                objects.push(mesh);
            }
        }

        // --- WEAPON RIG (HANDS + GUNS) ---
        function setupWeaponRig() {
            weaponRig = new THREE.Group();
            camera.add(weaponRig);
            
            // Default position offset for right-handed shooter
            weaponRig.position.set(0.25, -0.25, -0.4); 

            // Initialize all weapon models
            // We build them procedurally to keep single file
            
            // 1. GLOCK
            const glockGroup = new THREE.Group();
            glockGroup.userData = { type: 'glock', rate: 150, dmg: 25, recoil: 0.02 };
            // Slide
            const gSlide = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            gSlide.userData.part = 'skin'; // This part gets painted
            // Handle
            const gHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.07), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            gHandle.position.set(0, -0.08, 0.1); gHandle.rotation.x = 0.2;
            // Hands
            addHands(glockGroup, 'pistol');
            glockGroup.add(gSlide, gHandle);
            glockGroup.visible = false;
            weaponRig.add(glockGroup);

            // 2. AWP
            const awpGroup = new THREE.Group();
            awpGroup.userData = { type: 'awp', rate: 1200, dmg: 110, recoil: 0.15 };
            const aBody = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.8), new THREE.MeshStandardMaterial({ color: 0x223322 }));
            aBody.userData.part = 'skin';
            const aBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            aBarrel.rotation.x = Math.PI/2; aBarrel.position.z = -0.6;
            const aScope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            aScope.rotation.x = Math.PI/2; aScope.position.y = 0.12;
            addHands(awpGroup, 'rifle');
            awpGroup.add(aBody, aBarrel, aScope);
            awpGroup.visible = false;
            weaponRig.add(awpGroup);

            // 3. KNIFE
            const knifeGroup = new THREE.Group();
            knifeGroup.userData = { type: 'knife', rate: 500, dmg: 50, recoil: 0 };
            const kBlade = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25, 0.01), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1, roughness: 0.2 }));
            kBlade.position.y = 0.15;
            kBlade.userData.part = 'skin';
            const kHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.12, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            addHands(knifeGroup, 'melee');
            knifeGroup.add(kBlade, kHandle);
            // Knife orientation
            knifeGroup.rotation.set(-1.5, 0, 0); 
            knifeGroup.position.set(0.1, 0, 0.1);
            knifeGroup.visible = false;
            weaponRig.add(knifeGroup);
        }

        function addHands(group, type) {
            const handMat = new THREE.MeshStandardMaterial({ color: 0xcca386 }); // Skin tone
            const sleeveMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Sleeve

            if (type === 'pistol') {
                // Right Arm
                const rArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.6), sleeveMat);
                rArm.rotation.x = Math.PI/2.5; rArm.position.set(0.15, -0.3, 0.3);
                group.add(rArm);
                // Left Arm (Support)
                const lArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.6), sleeveMat);
                lArm.rotation.x = Math.PI/2.5; lArm.rotation.y = -0.5; lArm.position.set(-0.2, -0.3, 0.3);
                group.add(lArm);
            } else if (type === 'rifle') {
                 // Right Arm
                 const rArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.6), sleeveMat);
                 rArm.rotation.x = Math.PI/2.2; rArm.position.set(0.15, -0.3, 0.4);
                 group.add(rArm);
                 // Left Arm (Barrel hold)
                 const lArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.7), sleeveMat);
                 lArm.rotation.x = Math.PI/2; lArm.rotation.z = 0.5; lArm.position.set(-0.3, -0.2, 0.0);
                 group.add(lArm);
            } else {
                 // Right Arm Only
                 const rArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.6), sleeveMat);
                 rArm.rotation.x = Math.PI/2; rArm.position.set(0.1, -0.3, 0.4);
                 group.add(rArm);
            }
        }

        // --- SKINS LOGIC ---
        function applySkin(weaponType, skinId) {
            State.inventory[weaponType] = skinId;
            saveState();

            // Find weapon group
            const group = weaponRig.children.find(c => c.userData.type === weaponType);
            if(!group) return;

            // Find skin definition
            const db = SKINS_DB[weaponType];
            const skinData = db.find(s => s.id === skinId);
            
            // Apply Material
            group.traverse(child => {
                if(child.isMesh && child.userData.part === 'skin') {
                    child.material.color.setHex(skinData.color);
                    child.material.roughness = skinData.roughness !== undefined ? skinData.roughness : 0.5;
                    child.material.metalness = skinData.metal !== undefined ? skinData.metal : 0.0;
                    if(skinData.em) child.material.emissive.setHex(skinData.em);
                    else child.material.emissive.setHex(0x000000);
                }
            });
        }

        function switchWeapon(type) {
            State.currentWeapon = type;
            
            // Visual toggle
            weaponRig.children.forEach(c => {
                c.visible = (c.userData.type === type);
                if(c.visible) currentWeaponMesh = c;
            });

            // Update UI
            document.getElementById('weapon-name').innerText = type.toUpperCase();
            document.getElementById('ammo-text').innerText = type === 'knife' ? '--' : '30 / 90';
            
            // Apply current skin
            applySkin(type, State.inventory[type]);
            
            // Reset recoil
            recoilPitch = 0;
            recoilZ = 0;
        }

        // --- GAMEPLAY LOGIC ---
        function shoot() {
            const now = performance.now();
            const config = currentWeaponMesh.userData;
            
            if(now - lastFireTime < config.rate) return;
            lastFireTime = now;

            // 1. Recoil Logic
            recoilZ += 0.2; // Push back weapon
            recoilPitch += config.recoil; // Pitch camera up
            
            // 2. Sound
            playSound(State.currentWeapon === 'knife' ? 'swing' : 'shot');

            // 3. Melee Logic
            if(State.currentWeapon === 'knife') {
                currentWeaponMesh.rotation.x -= 1.0; // Stab
                setTimeout(() => currentWeaponMesh.rotation.x += 1.0, 150);
                // Melee Raycast (short range)
                shootRay(2.5, config.dmg);
                return;
            }

            // 4. Ranged Logic
            // Muzzle Flash
            const muzzlePos = new THREE.Vector3(0, 0.05, -0.5);
            muzzlePos.applyMatrix4(currentWeaponMesh.matrixWorld);
            
            const flash = new THREE.PointLight(0xffaa00, 2, 5);
            flash.position.copy(muzzlePos);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);

            // Raycast
            shootRay(100, config.dmg, muzzlePos);
        }

        function shootRay(range, dmg, origin) {
            // Ray from camera center
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            
            // Check Hits
            const hitObjects = [...objects, ...bots.map(b=>b.mesh)];
            const intersects = raycaster.intersectObjects(hitObjects);

            let endPoint = new THREE.Vector3();
            // Default endpoint far away
            endPoint.copy(raycaster.ray.direction).multiplyScalar(range).add(raycaster.ray.origin);

            if(intersects.length > 0) {
                const hit = intersects[0];
                if(hit.distance <= range) {
                    endPoint.copy(hit.point);
                    handleHit(hit, dmg);
                }
            }

            // Draw Tracer
            if(State.currentWeapon !== 'knife') {
                createTracer(origin, endPoint);
            }
        }

        function createTracer(start, end) {
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            // Fade out
            let op = 1;
            const anim = () => {
                op -= 0.1;
                material.opacity = op;
                material.transparent = true;
                if(op > 0) requestAnimationFrame(anim);
                else { scene.remove(line); geometry.dispose(); material.dispose(); }
            };
            anim();
        }

        function handleHit(hit, dmg) {
            // Particle effect at hit point
            createParticles(hit.point, hit.object.userData.isBot ? 0xaa0000 : 0x555555);

            if(hit.object.userData.isBot) {
                const bot = hit.object.userData.ref;
                bot.hp -= dmg;
                
                // Feedback
                const feed = document.createElement('div');
                feed.className = 'kill-msg';
                feed.innerText = `HIT ${dmg}`;
                document.getElementById('killfeed').appendChild(feed);

                if(bot.hp <= 0) {
                    killBot(bot);
                }
            } else {
                // Bullet hole (decals are hard in pure ThreeJS without external textures, using small square)
                const hole = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), new THREE.MeshBasicMaterial({color:0x000000}));
                hole.position.copy(hit.point);
                hole.lookAt(hit.point.clone().add(hit.face.normal));
                hole.position.add(hit.face.normal.multiplyScalar(0.01)); // Z-fight fix
                scene.add(hole);
                setTimeout(() => scene.remove(hole), 5000);
            }
        }

        function createParticles(pos, color) {
            for(let i=0; i<5; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,0.05), new THREE.MeshBasicMaterial({color: color}));
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(0.2);
                scene.add(p);
                particles.push(p);
            }
        }

        // --- BOTS AI ---
        function spawnBots(count) {
            const geo = new THREE.CapsuleGeometry(0.5, 1.8, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0xaa4444 });
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*100);
                mesh.userData = { isBot: true, ref: null };
                
                const bot = {
                    mesh: mesh,
                    hp: 100,
                    speed: 3 + Math.random()*2,
                    state: 'idle'
                };
                mesh.userData.ref = bot;
                scene.add(mesh);
                bots.push(bot);
            }
        }

        function killBot(bot) {
            bot.hp = 100;
            // Respawn
            bot.mesh.position.set((Math.random()-0.5)*100, 1, (Math.random()-0.5)*100);
            // Reward
            State.money += 300;
            saveState();
            
            const msg = document.createElement('div');
            msg.className = 'kill-msg';
            msg.style.color = '#0f0';
            msg.innerText = `ENEMY DOWN +$300`;
            document.getElementById('killfeed').appendChild(msg);
        }

        function updateBots(delta) {
            bots.forEach(bot => {
                const dist = bot.mesh.position.distanceTo(camera.position);
                
                if(dist < 50) {
                    bot.mesh.lookAt(camera.position.x, 1, camera.position.z);
                    const dir = new THREE.Vector3(0,0,1).applyQuaternion(bot.mesh.quaternion);
                    bot.mesh.position.add(dir.multiplyScalar(bot.speed * delta));
                }
            });
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if(controls.isLocked) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= CONFIG.gravity * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * CONFIG.speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * CONFIG.speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 1.7) {
                    velocity.y = 0;
                    controls.getObject().position.y = 1.7;
                    canJump = true;
                }

                // Weapons
                if(isFiring) shoot();

                // 1. Recoil Recovery (Camera Pitch)
                camera.rotation.x += recoilPitch;
                recoilPitch *= 0.8; // Decay
                
                // Clamp Look
                // (Done inside pointerlock automatically somewhat, but manual clamping needed for pitch limit)
                
                // 2. Weapon Rig Animation
                // Sway
                const isMoving = velocity.length() > 1;
                const swayTargetX = isMoving ? Math.sin(time * 0.01) * 0.05 : 0;
                const swayTargetY = isMoving ? Math.cos(time * 0.02) * 0.05 : 0;
                
                // Smooth interpolation
                weaponRig.position.x = THREE.MathUtils.lerp(weaponRig.position.x, 0.25 + swayTargetX - (moveLeft?0.05:0) + (moveRight?0.05:0), 0.1);
                weaponRig.position.y = THREE.MathUtils.lerp(weaponRig.position.y, -0.25 + swayTargetY, 0.1);
                
                // Recoil Kickback
                weaponRig.position.z = THREE.MathUtils.lerp(weaponRig.position.z, -0.4 + recoilZ, 0.5);
                recoilZ *= 0.8; // Decay kickback

                // Bots
                updateBots(delta);
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.scale.multiplyScalar(0.9);
                if(p.scale.x < 0.01) {
                    scene.remove(p);
                    particles.splice(i,1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- INPUT HANDLERS ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = true; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = true; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = true; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) velocity.y += 10; canJump = false; break;
                case 'Digit1': switchWeapon('awp'); break;
                case 'Digit2': switchWeapon('glock'); break;
                case 'Digit3': switchWeapon('knife'); break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW': moveForward = false; break;
                case 'ArrowLeft':
                case 'KeyA': moveLeft = false; break;
                case 'ArrowDown':
                case 'KeyS': moveBackward = false; break;
                case 'ArrowRight':
                case 'KeyD': moveRight = false; break;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- AUDIO SYSTEM (SYNTH) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if(type === 'shot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'swing') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
        }

        // --- MENU & STATE SYSTEMS ---
        
        window.Game = {
            start: () => {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-hud').classList.remove('hidden');
                State.isPlaying = true;
                controls.lock();
                switchWeapon(State.currentWeapon);
            }
        };

        window.Menu = {
            openSkins: () => {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('skins-screen').classList.remove('hidden');
                Menu.filterSkins('glock'); // Default
                document.getElementById('balance-display').innerText = `BALANCE: $${State.money}`;
            },
            closeSkins: () => {
                document.getElementById('skins-screen').classList.add('hidden');
                document.getElementById('lobby-screen').classList.remove('hidden');
            },
            filterSkins: (type) => {
                const grid = document.getElementById('skins-grid');
                grid.innerHTML = '';
                const skins = SKINS_DB[type];
                
                skins.forEach(skin => {
                    const el = document.createElement('div');
                    const owned = State.ownedSkins.includes(skin.id);
                    const equipped = State.inventory[type] === skin.id;
                    
                    el.className = `skin-card ${equipped ? 'active' : ''}`;
                    el.innerHTML = `
                        <div class="rarity ${skin.rarity}">${skin.rarity.toUpperCase()}</div>
                        <div style="width:50px; height:50px; background:#${skin.color.toString(16)}; margin:10px auto; border-radius:5px; box-shadow:0 0 10px #${skin.em ? skin.em.toString(16) : '000'}"></div>
                        <strong>${skin.name}</strong>
                        ${!owned ? `<div class="price-tag">$${skin.price}</div>` : '<div style="color:#888; margin-top:5px;">OWNED</div>'}
                        ${equipped ? '<div style="color:#0f0; font-size:12px;">EQUIPPED</div>' : ''}
                    `;
                    
                    el.onclick = () => {
                        if(owned) {
                            State.inventory[type] = skin.id;
                            saveState();
                            Menu.filterSkins(type); // Refresh UI
                        } else {
                            if(State.money >= skin.price) {
                                State.money -= skin.price;
                                State.ownedSkins.push(skin.id);
                                State.inventory[type] = skin.id;
                                saveState();
                                document.getElementById('balance-display').innerText = `BALANCE: $${State.money}`;
                                Menu.filterSkins(type);
                            } else {
                                alert('Not enough money!');
                            }
                        }
                    };
                    grid.appendChild(el);
                });
            }
        };

        function saveState() {
            localStorage.setItem('fps_save_v1', JSON.stringify({
                money: State.money,
                inventory: State.inventory,
                ownedSkins: State.ownedSkins
            }));
        }

        function loadState() {
            const data = localStorage.getItem('fps_save_v1');
            if(data) {
                const parsed = JSON.parse(data);
                State.money = parsed.money;
                State.inventory = parsed.inventory;
                State.ownedSkins = parsed.ownedSkins;
            }
        }
    </script>
</body>
</html>
