<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JS FPS: Standoff Logic Core</title>
    <style>
        /* --- CORE UI STYLES --- */
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* LAYOUTS */
        .screen { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; pointer-events: none; }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }
        
        /* MENU STYLES */
        #menu-screen { background: rgba(15, 15, 20, 0.95); color: #fff; z-index: 10; align-items: center; justify-content: center; }
        .panel { background: rgba(30, 30, 40, 0.9); border: 1px solid #445; padding: 20px; border-radius: 8px; width: 80%; max-width: 800px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; max-height: 90%; overflow-y: auto; }
        
        h1, h2 { margin: 0 0 10px 0; color: #fb1; text-transform: uppercase; letter-spacing: 2px; }
        .stats-bar { display: flex; justify-content: space-between; background: #000; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-weight: bold; }
        .currency { color: #4f4; }
        
        .btn { background: #222; border: 1px solid #555; color: #eee; padding: 12px; cursor: pointer; text-transform: uppercase; font-weight: bold; transition: 0.2s; }
        .btn:hover { background: #333; border-color: #fb1; }
        .btn-primary { background: #b60; border-color: #e80; color: #fff; font-size: 1.2em; }
        .btn-primary:hover { background: #d70; }
        
        /* GRID FOR ITEMS */
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 10px; }
        .item-card { background: #1a1a1a; border: 1px solid #333; padding: 10px; text-align: center; cursor: pointer; position: relative; }
        .item-card:hover { border-color: #888; }
        .item-card.selected { border-color: #fb1; box-shadow: 0 0 10px rgba(255, 187, 17, 0.2); }
        .rarity-common { border-bottom: 3px solid #ccc; }
        .rarity-rare { border-bottom: 3px solid #48f; }
        .rarity-legendary { border-bottom: 3px solid #fb1; }
        
        /* HUD */
        #hud-screen { z-index: 5; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .hud-top { display: flex; justify-content: space-between; width: 100%; }
        .hud-bottom { display: flex; justify-content: space-between; align-items: flex-end; width: 100%; margin-top: auto; }
        
        .stat-box { background: rgba(0,0,0,0.5); padding: 10px 20px; color: #fff; font-size: 24px; font-weight: bold; border-left: 4px solid #fff; }
        .hp-box { border-color: #f33; }
        .armor-box { border-color: #33f; }
        .ammo-box { border-color: #fb1; text-align: right; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 0; height: 0; transform: translate(-50%, -50%); }
        .ch-part { position: absolute; background: #0f0; }
        .ch-h { width: 10px; height: 2px; top: -1px; left: -5px; }
        .ch-v { width: 2px; height: 10px; top: -5px; left: -1px; }
        
        #killfeed { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px; }
        .feed-item { background: rgba(0,0,0,0.6); color: #fff; padding: 5px 10px; border-radius: 4px; font-size: 14px; animation: fadeOut 4s forwards; }
        @keyframes fadeOut { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }

        /* MOBILE CONTROLS */
        #mobile-controls { display: none; position: absolute; width: 100%; height: 100%; z-index: 8; pointer-events: none; }
        .joystick-zone { position: absolute; width: 40%; height: 50%; bottom: 0; pointer-events: auto; }
        #stick-left-zone { left: 0; }
        #stick-right-zone { right: 0; }
        .action-btn { position: absolute; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; width: 60px; height: 60px; pointer-events: auto; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; }
        .action-btn:active { background: rgba(255,187,17,0.5); }
        #btn-shoot { bottom: 80px; right: 20px; width: 70px; height: 70px; border-color: #f55; background: rgba(255,0,0,0.1); }
        #btn-reload { bottom: 30px; right: 100px; }
        #btn-switch { bottom: 110px; right: 100px; }
        #btn-jump { bottom: 160px; right: 20px; }

        /* SHOP IN GAME */
        #ingame-shop { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 15; background: rgba(20,20,20,0.95); padding: 20px; border: 2px solid #fb1; display: none; pointer-events: auto; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="menu-screen" class="screen interactive">
        <div class="panel">
            <h1>FPS Project: Core</h1>
            <div class="stats-bar">
                <span>–ì—Ä–æ—à—ñ: <span id="menu-money" class="currency">$0</span></span>
                <span>–†—ñ–≤–µ–Ω—å: 1</span>
            </div>
            
            <button class="btn btn-primary" onclick="Game.startMatch()">–ì–†–ê–¢–ò</button>
            <div style="height: 20px;"></div>
            
            <div style="display: flex; gap: 5px;">
                <button class="btn" onclick="Menu.showTab('inventory')">–Ü–Ω–≤–µ–Ω—Ç–∞—Ä</button>
                <button class="btn" onclick="Menu.showTab('shop')">–ú–∞–≥–∞–∑–∏–Ω</button>
                <button class="btn" onclick="Menu.showTab('market')">–†–∏–Ω–æ–∫</button>
            </div>

            <hr style="width:100%; border: 0; border-top: 1px solid #444;">

            <div id="tab-inventory" class="tab-content">
                <h2>–í–∞—à –ê—Ä—Å–µ–Ω–∞–ª</h2>
                <div id="inventory-grid" class="grid"></div>
            </div>

            <div id="tab-shop" class="tab-content hidden">
                <h2>–ú–∞–≥–∞–∑–∏–Ω –∑–±—Ä–æ—ó</h2>
                <div id="shop-grid" class="grid"></div>
            </div>

            <div id="tab-market" class="tab-content hidden">
                <h2>–†–∏–Ω–æ–∫ –°–∫—ñ–Ω—ñ–≤</h2>
                <p style="font-size: 12px; color: #888;">–ö—É–ø—É–π—Ç–µ —Ä—ñ–¥–∫—ñ—Å–Ω—ñ —Å–∫—ñ–Ω–∏ —É —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤ (—Å–∏–º—É–ª—è—Ü—ñ—è)</p>
                <div id="market-grid" class="grid"></div>
            </div>
        </div>
    </div>

    <div id="hud-screen" class="screen hidden">
        <div id="killfeed"></div>
        
        <div id="crosshair">
            <div class="ch-part ch-h"></div>
            <div class="ch-part ch-v"></div>
        </div>

        <div class="hud-top">
            <div class="stat-box"><span id="hud-score-t">0</span> : <span id="hud-score-ct">0</span></div>
            <div class="stat-box currency" id="hud-money">$800</div>
        </div>

        <div class="hud-bottom">
            <div style="display:flex; gap: 10px;">
                <div class="stat-box hp-box" id="hud-hp">100 HP</div>
                <div class="stat-box armor-box" id="hud-armor">0 AP</div>
            </div>
            <div class="stat-box ammo-box" id="hud-ammo">30 / 90</div>
        </div>
        
        <div style="position: absolute; left: 20px; top: 50%; opacity: 0.5; font-size: 12px;" id="pc-hints">
            [B] –ú–∞–≥–∞–∑–∏–Ω | [R] –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ | [1-3] –ó–±—Ä–æ—è
        </div>
    </div>

    <div id="ingame-shop">
        <h2>–ó–∞–∫—É–ø—ñ–≤–ª—è</h2>
        <div class="grid" id="ingame-shop-grid" style="width: 500px;"></div>
        <button class="btn" onclick="Game.toggleShop()" style="margin-top: 10px; width: 100%;">–ó–∞–∫—Ä–∏—Ç–∏</button>
    </div>

    <div id="mobile-controls">
        <div id="stick-left-zone" class="joystick-zone"></div>
        <div id="stick-right-zone" class="joystick-zone"></div>
        
        <div id="btn-shoot" class="action-btn">FIRE</div>
        <div id="btn-reload" class="action-btn">R</div>
        <div id="btn-switch" class="action-btn">SW</div>
        <div id="btn-jump" class="action-btn">J</div>
    </div>

<script>
/**
 * ------------------------------------------------------------------
 * CONFIGURATION & DATA
 * ------------------------------------------------------------------
 */
const CONFIG = {
    sensitivity: 0.002,
    mobileSensitivity: 0.005,
    gravity: 30,
    speed: 15,
    jumpForce: 12
};

// –ó–ë–†–û–Ø –¢–ê –•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò
const WEAPONS = {
    KNIFE: { id: 'knife', name: 'N-Knife', type: 'melee', damage: 35, fireRate: 0.5, range: 3, recoil: 0, price: 0, clip: 0 },
    PISTOL: { id: 'pistol', name: 'G-22', type: 'pistol', damage: 24, fireRate: 0.15, range: 50, recoil: 0.02, spread: 0.02, price: 300, clip: 20, reserve: 100, reloadTime: 1.5 },
    RIFLE: { id: 'rifle', name: 'AK-47', type: 'rifle', damage: 32, fireRate: 0.1, range: 100, recoil: 0.04, spread: 0.01, price: 2700, clip: 30, reserve: 90, reloadTime: 2.2 },
    SNIPER: { id: 'sniper', name: 'AWM', type: 'sniper', damage: 110, fireRate: 1.2, range: 200, recoil: 0.1, spread: 0.001, price: 4750, clip: 10, reserve: 30, reloadTime: 3.0 }
};

// –ë–ê–ó–ê –°–ö–Ü–ù–Ü–í (–ö–æ–ª—å–æ—Ä–∏ –∑–∞–º—ñ—Å—Ç—å —Ç–µ–∫—Å—Ç—É—Ä –¥–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó –±–µ–∑ –∞—Å—Å–µ—Ç—ñ–≤)
const SKINS = {
    'default': { name: 'Standard', color: 0x333333, rarity: 'common' },
    'red_dragon': { name: 'Red Dragon', color: 0xaa0000, rarity: 'legendary', price: 1500 },
    'blue_camo': { name: 'Blue Camo', color: 0x0044aa, rarity: 'rare', price: 400 },
    'gold': { name: 'Gold Dust', color: 0xffd700, rarity: 'legendary', price: 5000 },
    'forest': { name: 'Forest', color: 0x225522, rarity: 'common', price: 50 }
};

/**
 * ------------------------------------------------------------------
 * SYSTEM 1: PERSISTENCE & INVENTORY (LocalStorage)
 * ------------------------------------------------------------------
 */
const UserData = {
    money: 1000,
    inventory: [
        { uid: 1, weaponId: 'knife', skinId: 'default', equipped: true },
        { uid: 2, weaponId: 'pistol', skinId: 'default', equipped: true },
        { uid: 3, weaponId: 'rifle', skinId: 'default', equipped: true }
    ],
    
    load() {
        const data = localStorage.getItem('fps_save_v1');
        if (data) {
            const parsed = JSON.parse(data);
            this.money = parsed.money;
            this.inventory = parsed.inventory;
        }
        this.updateUI();
    },

    save() {
        localStorage.setItem('fps_save_v1', JSON.stringify({
            money: this.money,
            inventory: this.inventory
        }));
        this.updateUI();
    },

    updateUI() {
        document.getElementById('menu-money').innerText = `$${this.money}`;
        document.getElementById('hud-money').innerText = `$${this.money}`;
    },

    getEquippedSkin(weaponId) {
        const item = this.inventory.find(i => i.weaponId === weaponId && i.equipped);
        return item ? item.skinId : 'default';
    }
};

/**
 * ------------------------------------------------------------------
 * SYSTEM 2: ENGINE & RENDERER
 * ------------------------------------------------------------------
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // Skybox
scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.getElementById('game-container').appendChild(renderer.domElement);

// –°–≤—ñ—Ç–ª–æ
const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(50, 100, 50);
dirLight.castShadow = true;
scene.add(dirLight);

/**
 * ------------------------------------------------------------------
 * SYSTEM 3: INPUT MANAGER (PC + MOBILE)
 * ------------------------------------------------------------------
 */
const Input = {
    keys: {},
    moveVector: { x: 0, z: 0 },
    lookVector: { x: 0, y: 0 },
    isMobile: /Android|iPhone|iPad/i.test(navigator.userAgent),
    isFiring: false,
    
    init() {
        // PC Controls
        document.addEventListener('keydown', (e) => this.keys[e.code] = true);
        document.addEventListener('keyup', (e) => this.keys[e.code] = false);
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                Player.rotate(e.movementX, e.movementY);
            }
        });
        document.addEventListener('mousedown', () => {
            if (Game.state === 'PLAYING') {
                if (document.pointerLockElement !== document.body && !this.isMobile) {
                    document.body.requestPointerLock();
                } else {
                    this.isFiring = true;
                }
            }
        });
        document.addEventListener('mouseup', () => this.isFiring = false);
        
        // Key binds
        document.addEventListener('keydown', (e) => {
            if (Game.state !== 'PLAYING') return;
            if (e.code === 'KeyR') Player.reload();
            if (e.code === 'KeyB') Game.toggleShop();
            if (e.code === 'Digit1') Player.switchWeapon('rifle');
            if (e.code === 'Digit2') Player.switchWeapon('pistol');
            if (e.code === 'Digit3') Player.switchWeapon('knife');
            if (e.code === 'Space') Player.jump();
        });

        // Mobile Controls
        if (this.isMobile) {
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('pc-hints').style.display = 'none';
            this.setupTouch();
        }
    },

    setupTouch() {
        // Simple Virtual Joystick Implementation
        const handleJoystick = (zone, callback) => {
            let startX, startY;
            zone.addEventListener('touchstart', (e) => {
                startX = e.changedTouches[0].clientX;
                startY = e.changedTouches[0].clientY;
            });
            zone.addEventListener('touchmove', (e) => {
                const dx = e.changedTouches[0].clientX - startX;
                const dy = e.changedTouches[0].clientY - startY;
                callback(dx, dy);
            });
            zone.addEventListener('touchend', () => callback(0, 0));
        };

        handleJoystick(document.getElementById('stick-left-zone'), (x, y) => {
            // Limit output to -1 to 1
            this.moveVector.x = Math.max(-1, Math.min(1, x / 50));
            this.moveVector.z = Math.max(-1, Math.min(1, y / 50));
        });

        handleJoystick(document.getElementById('stick-right-zone'), (x, y) => {
            // Camera rotation logic for touch
            Player.rotate(x * 5, y * 5); // Sensitivity multiplier
        });

        // Buttons
        document.getElementById('btn-shoot').addEventListener('touchstart', (e) => { e.preventDefault(); this.isFiring = true; });
        document.getElementById('btn-shoot').addEventListener('touchend', (e) => { e.preventDefault(); this.isFiring = false; });
        document.getElementById('btn-reload').addEventListener('touchstart', (e) => { e.preventDefault(); Player.reload(); });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); Player.jump(); });
        document.getElementById('btn-switch').addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            // Simple cycle for mobile
            const order = ['rifle', 'pistol', 'knife'];
            const currentIdx = order.indexOf(Player.currentWeapon.data.id);
            Player.switchWeapon(order[(currentIdx + 1) % 3]);
        });
    },

    getMovement() {
        if (this.isMobile) return this.moveVector;
        
        let x = 0, z = 0;
        if (this.keys['KeyW']) z = -1;
        if (this.keys['KeyS']) z = 1;
        if (this.keys['KeyA']) x = -1;
        if (this.keys['KeyD']) x = 1;
        return { x, z };
    }
};

/**
 * ------------------------------------------------------------------
 * SYSTEM 4: WEAPON & ANIMATION SYSTEM
 * ------------------------------------------------------------------
 */
class WeaponModel {
    constructor(type, skinColor) {
        this.mesh = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: skinColor });
        const grey = new THREE.MeshStandardMaterial({ color: 0x222222 });

        if (type === 'pistol') {
            const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), material);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.15, 0.1), grey);
            handle.position.set(0, -0.1, 0.1);
            handle.rotation.x = 0.2;
            this.mesh.add(barrel, handle);
        } else if (type === 'rifle') {
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), material);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4), grey);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = -0.4;
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.15), grey);
            mag.position.set(0, -0.2, 0.1);
            mag.rotation.x = 0.2;
            this.mesh.add(body, barrel, mag);
        } else if (type === 'knife') {
            const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.02, 0.4), material); // –õ–µ–∑–æ
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.15), grey);
            handle.rotation.x = Math.PI / 2;
            handle.position.z = 0.25;
            this.mesh.add(blade, handle);
        }

        // –ü–æ–∑–∏—Ü—ñ—è –∑–±—Ä–æ—ó –≤—ñ–¥–Ω–æ—Å–Ω–æ –∫–∞–º–µ—Ä–∏ (Hands)
        this.mesh.position.set(0.3, -0.25, -0.5);
        this.basePos = this.mesh.position.clone();
    }
}

/**
 * ------------------------------------------------------------------
 * SYSTEM 5: PLAYER CONTROLLER
 * ------------------------------------------------------------------
 */
const Player = {
    mesh: new THREE.Object3D(), // –¢—ñ–ª–æ –≥—Ä–∞–≤—Ü—è (–Ω–µ–≤–∏–¥–∏–º–µ, –¥–ª—è —Ñ—ñ–∑–∏–∫–∏)
    pitchObject: new THREE.Object3D(), // –î–ª—è –ø–æ–≤–æ—Ä–æ—Ç—É –≥–æ–ª–æ–≤–∏ (–≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)
    velocity: new THREE.Vector3(),
    onGround: false,
    hp: 100,
    armor: 0,
    money: 800,
    weapons: {},
    currentWeapon: null,
    
    // Recoil vars
    recoilPitch: 0,
    recoilYaw: 0,
    
    init() {
        scene.add(this.mesh);
        this.mesh.add(this.pitchObject);
        this.pitchObject.add(camera);
        this.mesh.position.y = 2; // –í–∏—Å–æ—Ç–∞ –æ—á–µ–π

        // Initialize weapons with inventory skins
        this.loadLoadout();
    },

    loadLoadout() {
        // –û—á–∏—Å—Ç–∏—Ç–∏ —Å—Ç–∞—Ä—É –∑–±—Ä–æ—é
        if(this.currentWeapon) this.pitchObject.remove(this.currentWeapon.model.mesh);
        
        ['knife', 'pistol', 'rifle', 'sniper'].forEach(type => {
            const skinId = UserData.getEquippedSkin(type);
            const color = SKINS[skinId].color;
            
            // Logic Object
            this.weapons[type] = {
                data: WEAPONS[type.toUpperCase()],
                model: new WeaponModel(type, color),
                ammo: WEAPONS[type.toUpperCase()].clip,
                reserve: WEAPONS[type.toUpperCase()].reserve,
                lastShot: 0,
                reloading: false
            };
        });

        this.switchWeapon('pistol');
    },

    switchWeapon(type) {
        if (!this.weapons[type]) return; // –Ø–∫—â–æ –∑–±—Ä–æ—ó –Ω–µ–º–∞
        if (this.currentWeapon) {
            this.pitchObject.remove(this.currentWeapon.model.mesh);
            this.currentWeapon.reloading = false; // Cancel reload
        }
        this.currentWeapon = this.weapons[type];
        this.pitchObject.add(this.currentWeapon.model.mesh);
        this.updateHUD();
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è –¥—ñ—Å—Ç–∞–≤–∞–Ω–Ω—è
        this.currentWeapon.model.mesh.rotation.x = Math.PI / 2;
        new TWEEN(this.currentWeapon.model.mesh.rotation, { x: 0 }, 300);
    },

    update(dt) {
        if (this.hp <= 0) return;

        // 1. Movement Logic
        const input = Input.getMovement();
        const speed = CONFIG.speed;
        
        // Local movement to Global
        const direction = new THREE.Vector3(input.x, 0, input.z);
        direction.applyEuler(new THREE.Euler(0, this.mesh.rotation.y, 0));
        
        if (input.x !== 0 || input.z !== 0) {
            this.velocity.x = direction.x * speed;
            this.velocity.z = direction.z * speed;
            // Bobbing animation
            const time = Date.now() * 0.01;
            this.currentWeapon.model.mesh.position.y = this.currentWeapon.model.basePos.y + Math.sin(time) * 0.005;
            this.currentWeapon.model.mesh.position.x = this.currentWeapon.model.basePos.x + Math.cos(time * 0.5) * 0.005;
        } else {
            this.velocity.x *= 0.9; // Friction
            this.velocity.z *= 0.9;
            // Return to base pos
            this.currentWeapon.model.mesh.position.lerp(this.currentWeapon.model.basePos, 0.1);
        }

        // Gravity
        this.velocity.y -= CONFIG.gravity * dt;
        
        // Apply Move
        this.mesh.position.add(this.velocity.clone().multiplyScalar(dt));

        // Floor Collision (Primitive)
        if (this.mesh.position.y < 2) {
            this.mesh.position.y = 2;
            this.velocity.y = 0;
            this.onGround = true;
        }

        // 2. Shooting Logic
        if (Input.isFiring && !this.currentWeapon.reloading) {
            this.fire();
        }

        // 3. Recoil Recovery
        this.recoilPitch = THREE.MathUtils.lerp(this.recoilPitch, 0, dt * 5);
        this.recoilYaw = THREE.MathUtils.lerp(this.recoilYaw, 0, dt * 5);
        this.pitchObject.rotation.x = Math.max(-1.5, Math.min(1.5, this.pitchObject.rotation.x - this.recoilPitch * 0.1));

        // Weapon Kickback Animation return
        this.currentWeapon.model.mesh.position.z = THREE.MathUtils.lerp(this.currentWeapon.model.mesh.position.z, this.currentWeapon.model.basePos.z, dt * 10);
    },

    rotate(dx, dy) {
        if (this.hp <= 0) return;
        const sens = Input.isMobile ? CONFIG.mobileSensitivity : CONFIG.sensitivity;
        
        this.mesh.rotation.y -= dx * sens;
        this.pitchObject.rotation.x -= dy * sens;
        
        // Clamp look up/down
        this.pitchObject.rotation.x = Math.max(-1.5, Math.min(1.5, this.pitchObject.rotation.x));
    },

    jump() {
        if (this.onGround) {
            this.velocity.y = CONFIG.jumpForce;
            this.onGround = false;
        }
    },

    fire() {
        const now = Date.now() / 1000;
        const w = this.currentWeapon;
        
        if (now - w.lastShot < w.data.fireRate) return;
        if (w.ammo <= 0) {
            this.reload();
            return;
        }

        // Effect: Recoil
        w.lastShot = now;
        w.ammo--;
        
        // Visual Kickback
        w.model.mesh.position.z += 0.1;
        
        // Camera Recoil
        this.recoilPitch = w.data.recoil;
        this.pitchObject.rotation.x += w.data.recoil; 
        
        // Raycast Shoot
        // Calculate Spread
        const spreadX = (Math.random() - 0.5) * w.data.spread;
        const spreadY = (Math.random() - 0.5) * w.data.spread;
        
        const raycaster = new THREE.Raycaster();
        // Start from camera center but modified by spread
        raycaster.setFromCamera({ x: spreadX, y: spreadY }, camera);
        
        const hits = raycaster.intersectObjects(scene.children, true);
        
        // Logic hit processing
        for (let hit of hits) {
            if (hit.object.userData.isEnemy) {
                // Hit enemy
                const dmg = w.data.damage; // Simple damage, can add headshot multiplier logic based on hit.point.y
                hit.object.userData.parentBot.takeDamage(dmg);
                
                // Hitmarker visual (briefly change crosshair color)
                const ch = document.getElementsByClassName('ch-part');
                ch[0].style.backgroundColor = 'red'; ch[1].style.backgroundColor = 'red';
                setTimeout(()=> { ch[0].style.backgroundColor = '#0f0'; ch[1].style.backgroundColor = '#0f0'; }, 100);
                break; // Hit only one enemy per shot
            }
            if (hit.distance > w.data.range) break;
            
            // Wall decal (simplified: create small plane)
            if (!hit.object.userData.isPlayer && !hit.object.userData.isEnemy) {
                const decal = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), new THREE.MeshBasicMaterial({color: 0x000000}));
                decal.position.copy(hit.point);
                decal.lookAt(hit.point.clone().add(hit.face.normal));
                decal.position.add(hit.face.normal.multiplyScalar(0.01));
                scene.add(decal);
                setTimeout(() => scene.remove(decal), 5000);
                break; // Stop at wall
            }
        }
        
        this.updateHUD();
    },

    reload() {
        const w = this.currentWeapon;
        if (w.reloading || w.ammo === w.data.clip || w.reserve <= 0) return;
        
        w.reloading = true;
        // Animation
        w.model.mesh.rotation.x = -0.5;
        
        // Message
        Game.showMsg("Reloading...");

        setTimeout(() => {
            const needed = w.data.clip - w.ammo;
            const take = Math.min(needed, w.reserve);
            w.ammo += take;
            w.reserve -= take;
            w.reloading = false;
            w.model.mesh.rotation.x = 0;
            this.updateHUD();
        }, w.data.reloadTime * 1000);
    },

    takeDamage(amount) {
        if (this.armor > 0) {
            const abs = amount * 0.5;
            this.armor = Math.max(0, this.armor - abs);
            this.hp -= (amount - abs);
        } else {
            this.hp -= amount;
        }
        
        this.updateHUD();
        
        if (this.hp <= 0) Game.endMatch(false);
    },

    updateHUD() {
        if (!this.currentWeapon) return;
        document.getElementById('hud-ammo').innerText = `${this.currentWeapon.ammo} / ${this.currentWeapon.reserve}`;
        document.getElementById('hud-hp').innerText = `${Math.ceil(this.hp)} HP`;
        document.getElementById('hud-armor').innerText = `${Math.ceil(this.armor)} AP`;
    }
};

/**
 * ------------------------------------------------------------------
 * SYSTEM 6: AI / BOTS
 * ------------------------------------------------------------------
 */
class Bot {
    constructor(x, z) {
        this.hp = 100;
        
        // Geometry (Hitbox)
        const geometry = new THREE.BoxGeometry(1, 2, 1);
        const material = new THREE.MeshLambertMaterial({ color: 0xff4444 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 2, z);
        this.mesh.castShadow = true;
        this.mesh.userData = { isEnemy: true, parentBot: this };
        
        scene.add(this.mesh);
        
        this.lastAttack = 0;
        this.speed = 4 + Math.random() * 2;
    }

    update(dt) {
        if (this.hp <= 0) return;

        // Simple AI: Move towards player
        const playerPos = Player.mesh.position;
        const dist = this.mesh.position.distanceTo(playerPos);
        
        this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
        
        if (dist > 5) {
            // Chase
            const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
            this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
        } else {
            // Attack
            const now = Date.now() / 1000;
            if (now - this.lastAttack > 1.0) { // 1 sec fire rate
                Player.takeDamage(10 + Math.random() * 10);
                this.lastAttack = now;
                
                // Muzzle flash visual
                const flash = new THREE.PointLight(0xffaa00, 1, 3);
                flash.position.copy(this.mesh.position);
                flash.position.y += 0.5;
                flash.position.add(this.mesh.getWorldDirection(new THREE.Vector3()));
                scene.add(flash);
                setTimeout(()=> scene.remove(flash), 50);
            }
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        // Damage Flash
        this.mesh.material.emissive.setHex(0xffffff);
        setTimeout(() => this.mesh.material.emissive.setHex(0x000000), 50);

        if (this.hp <= 0) {
            this.die();
        }
    }

    die() {
        scene.remove(this.mesh);
        Game.bots = Game.bots.filter(b => b !== this);
        Game.killFeed('Player', 'Bot');
        Game.score.t += 1; // Bots are T
        Player.money += 300;
        UserData.money += 50; // Persistent meta-currency
        UserData.save();
        
        // Respawn new bot
        setTimeout(() => Game.spawnBot(), 3000);
    }
}

/**
 * ------------------------------------------------------------------
 * SYSTEM 7: MAP GENERATOR (Procedural CS-style layout)
 * ------------------------------------------------------------------
 */
function createMap() {
    // Floor
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Walls function
    function createWall(x, z, w, h, d) {
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshStandardMaterial({ color: 0x666666 }) // Gray walls
        );
        wall.position.set(x, h/2, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
    }

    // Boxes (Cover)
    function createBox(x, z) {
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 1.5, 1.5),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 }) // Wood
        );
        box.position.set(x, 0.75, z);
        box.castShadow = true;
        scene.add(box);
    }

    // Border Walls
    createWall(0, -50, 100, 10, 2);
    createWall(0, 50, 100, 10, 2);
    createWall(-50, 0, 2, 10, 100);
    createWall(50, 0, 2, 10, 100);

    // Mid obstacles
    createWall(0, 0, 10, 4, 10); // Central block
    createWall(-20, 10, 15, 4, 2);
    createWall(20, -10, 2, 4, 15);

    // Random covers
    createBox(-10, -10);
    createBox(15, 15);
    createBox(-15, 20);
    createBox(10, -20);
}

/**
 * ------------------------------------------------------------------
 * SYSTEM 8: UI & MENUS
 * ------------------------------------------------------------------
 */
const Menu = {
    renderInventory() {
        const container = document.getElementById('inventory-grid');
        container.innerHTML = '';
        
        UserData.inventory.forEach(item => {
            const skin = SKINS[item.skinId];
            const div = document.createElement('div');
            div.className = `item-card rarity-${skin.rarity} ${item.equipped ? 'selected' : ''}`;
            div.innerHTML = `
                <div style="width:30px; height:30px; background:#${skin.color.toString(16)}; margin: 0 auto;"></div>
                <strong>${WEAPONS[item.weaponId.toUpperCase()].name}</strong><br>
                <small>${skin.name}</small><br>
                ${!item.equipped ? `<button class="btn" style="font-size:10px; padding:2px;" onclick="Menu.equip(${item.uid})">Equip</button>` : 'Equipped'}
            `;
            container.appendChild(div);
        });
    },

    equip(uid) {
        const item = UserData.inventory.find(i => i.uid === uid);
        if (item) {
            // Unequip others of same type
            UserData.inventory.forEach(i => {
                if (i.weaponId === item.weaponId) i.equipped = false;
            });
            item.equipped = true;
            UserData.save();
            this.renderInventory();
        }
    },

    renderShop() {
        const container = document.getElementById('shop-grid');
        container.innerHTML = ''; // Placeholder for full weapon buying in menu? Usually in game.
        container.innerHTML = '–ó–±—Ä–æ—è –∫—É–ø—É—î—Ç—å—Å—è –ø—ñ–¥ —á–∞—Å –º–∞—Ç—á—É –Ω–∞ –∫–Ω–æ–ø–∫—É B';
    },

    renderMarket() {
        const container = document.getElementById('market-grid');
        container.innerHTML = '';
        // Fake Market Listings
        const listings = [
            { w: 'rifle', s: 'red_dragon', price: 1500 },
            { w: 'pistol', s: 'gold', price: 5000 },
            { w: 'knife', s: 'blue_camo', price: 400 }
        ];

        listings.forEach(l => {
            const div = document.createElement('div');
            div.className = 'item-card';
            div.innerHTML = `
                <strong>${SKINS[l.s].name}</strong><br>
                <span class="currency">$${l.price}</span><br>
                <button class="btn" onclick="Menu.buySkin('${l.w}', '${l.s}', ${l.price})">–ö—É–ø–∏—Ç–∏</button>
            `;
            container.appendChild(div);
        });
    },

    buySkin(wid, sid, price) {
        if (UserData.money >= price) {
            UserData.money -= price;
            UserData.inventory.push({
                uid: Date.now(),
                weaponId: wid,
                skinId: sid,
                equipped: false
            });
            UserData.save();
            alert('–°–∫—ñ–Ω –∫—É–ø–ª–µ–Ω–æ!');
            this.renderMarket();
            this.renderInventory();
        } else {
            alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –≥—Ä–æ—à–µ–π!');
        }
    },

    showTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
        document.getElementById('tab-' + tabId).classList.remove('hidden');
        if (tabId === 'inventory') this.renderInventory();
        if (tabId === 'market') this.renderMarket();
    }
};

/**
 * ------------------------------------------------------------------
 * MAIN GAME LOGIC
 * ------------------------------------------------------------------
 */
const Game = {
    state: 'MENU', // MENU, PLAYING
    bots: [],
    score: { ct: 0, t: 0 },
    
    init() {
        UserData.load();
        Menu.renderInventory();
        createMap();
        Input.init();
        
        // Render Loop
        const clock = new THREE.Clock();
        const animate = () => {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1); // Cap delta

            if (this.state === 'PLAYING') {
                Player.update(dt);
                this.bots.forEach(b => b.update(dt));
            }
            
            renderer.render(scene, camera);
        };
        animate();
    },

    startMatch() {
        this.state = 'PLAYING';
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('hud-screen').classList.remove('hidden');
        
        // Reset Player
        Player.init();
        Player.hp = 100;
        Player.mesh.position.set(0, 2, 40); // Spawn CT
        
        // Spawn Bots
        this.bots.forEach(b => scene.remove(b.mesh));
        this.bots = [];
        for(let i=0; i<3; i++) this.spawnBot();

        // Lock pointer
        if (!Input.isMobile) document.body.requestPointerLock();
    },

    spawnBot() {
        const x = (Math.random() - 0.5) * 60;
        const z = -40 + (Math.random() * 20); // Spawn T side
        this.bots.push(new Bot(x, z));
    },

    endMatch(win) {
        this.state = 'MENU';
        document.exitPointerLock();
        document.getElementById('menu-screen').classList.remove('hidden');
        document.getElementById('hud-screen').classList.add('hidden');
        document.getElementById('mobile-controls').style.display = 'none';
        alert(win ? "VICTORY" : "DEFEAT");
    },

    showMsg(text) {
        // Simple hud message
        const div = document.createElement('div');
        div.innerText = text;
        div.style.cssText = "position:absolute; top:40%; left:50%; transform:translate(-50%,-50%); color:white; font-size:20px; font-weight:bold;";
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1000);
    },

    killFeed(killer, victim) {
        const feed = document.getElementById('killfeed');
        const item = document.createElement('div');
        item.className = 'feed-item';
        item.innerHTML = `<b>${killer}</b> <span style="color:#f55">üî´</span> ${victim}`;
        feed.appendChild(item);
        setTimeout(() => item.remove(), 4000);
    },

    toggleShop() {
        if (this.state !== 'PLAYING') return;
        const shopEl = document.getElementById('ingame-shop');
        const isOpen = shopEl.style.display === 'block';
        
        if (isOpen) {
            shopEl.style.display = 'none';
            if (!Input.isMobile) document.body.requestPointerLock();
        } else {
            document.exitPointerLock();
            shopEl.style.display = 'block';
            this.renderInGameShop();
        }
    },

    renderInGameShop() {
        const grid = document.getElementById('ingame-shop-grid');
        grid.innerHTML = '';
        Object.values(WEAPONS).forEach(w => {
            if (w.price === 0) return;
            const div = document.createElement('div');
            div.className = 'item-card';
            div.innerHTML = `
                <strong>${w.name}</strong><br>
                <span class="currency">$${w.price}</span><br>
                <button class="btn" onclick="Game.buyWeapon('${w.id}')">–ö—É–ø–∏—Ç–∏</button>
            `;
            grid.appendChild(div);
        });
    },

    buyWeapon(id) {
        const wData = WEAPONS[id.toUpperCase()];
        if (Player.money >= wData.price) {
            Player.money -= wData.price;
            Player.switchWeapon(id);
            Player.currentWeapon.ammo = wData.clip;
            Player.currentWeapon.reserve = wData.reserve;
            this.toggleShop(); // close shop
        } else {
            alert('–ù–µ–º–∞—î –≥—Ä–æ—à–µ–π!');
        }
    }
};

// HELPER TWEEN (Simple linear interpolation helper)
class TWEEN {
    constructor(target, to, duration) {
        const start = {};
        for(let k in to) start[k] = target[k];
        const startTime = Date.now();
        
        const tick = () => {
            const now = Date.now();
            const progress = Math.min(1, (now - startTime) / duration);
            
            for(let k in to) {
                target[k] = start[k] + (to[k] - start[k]) * progress;
            }
            
            if (progress < 1) requestAnimationFrame(tick);
        };
        tick();
    }
}

// Start
window.onload = () => Game.init();

</script>
</body>
</html>
