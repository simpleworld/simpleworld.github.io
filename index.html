<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Browser Shooter (Three.js)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #111;
            user-select: none;
        }

        /* Екран блокування / Меню */
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 10;
        }

        #instructions {
            font-size: 24px;
            cursor: pointer;
            text-align: center;
            line-height: 1.5;
        }

        /* Приціл */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; } /* Горизонтальна */
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; } /* Вертикальна */

        /* Інтерфейс (HUD) */
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-size: 20px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }

        .weapon-info {
            font-size: 28px;
            font-weight: bold;
        }

        #ammo {
            margin-top: 5px;
            color: #fff;
        }

        /* Допоміжні написи */
        #controls-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            text-align: right;
        }
    </style>
</head>
<body>

    <div id="blocker">
        <div id="instructions">
            <span style="font-size:40px">КЛІКНИ ЩОБ ГРАТИ</span>
            <br /><br />
            (W, A, S, D = Рух, SPACE = Стрибок, MOUSE = Огляд)<br/>
            (1 = AK-47, 2 = Glock, 3 = Ніж)<br/>
            (ЛКМ = Стріляти)
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="hud">
        <div class="weapon-info" id="weapon-name">AK-47</div>
        <div id="ammo">Патрони: ∞</div>
    </div>
    
    <div id="controls-hint">
        WASD - Рух<br>1, 2, 3 - Зміна зброї
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Глобальні змінні ---
        let camera, scene, renderer, controls;
        let raycaster;
        
        // Фізика руху
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Світ та колізії
        const objects = []; // Об'єкти, з якими можна зіткнутися (підлога, стіни)
        const walls = [];   // Тільки стіни для перевірки колізії руху

        // Зброя
        let weaponMeshGroup;
        let activeWeaponIndex = 0; // 0: AK, 1: Glock, 2: Knife
        let isFiring = false;
        let lastFireTime = 0;
        
        // Налаштування зброї
        const weapons = [
            { 
                name: "AK-47", 
                type: "auto", 
                rate: 100, // мс між пострілами
                damage: 30, 
                recoil: 0.05,
                color: 0x444444 
            },
            { 
                name: "Glock", 
                type: "semi", 
                rate: 250, 
                damage: 15, 
                recoil: 0.02,
                color: 0x222222 
            },
            { 
                name: "Ніж", 
                type: "melee", 
                rate: 500, 
                damage: 50, 
                recoil: 0.1,
                color: 0x888888 
            }
        ];

        // Аудіо контекст (для синтезу звуків)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // --- Ініціалізація ---
        init();
        animate();

        function init() {
            // 1. Сцена та Камера
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Блакитне небо
            scene.fog = new THREE.Fog(0x87CEEB, 0, 750);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 10; // Висота очей

            // 2. Світло
            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 200, 100);
            scene.add(dirLight);

            // 3. Управління (Pointer Lock)
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', function () {
                controls.lock();
                // Активуємо аудіо при першому кліку
                if (audioCtx.state === 'suspended') audioCtx.resume();
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });

            scene.add(controls.getObject());

            // 4. Обробка клавіш
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if (canJump === true) velocity.y += 350; 
                        canJump = false; 
                        break;
                    case 'Digit1': switchWeapon(0); break;
                    case 'Digit2': switchWeapon(1); break;
                    case 'Digit3': switchWeapon(2); break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Стрільба мишею
            document.addEventListener('mousedown', function(e) {
                if (controls.isLocked) {
                    isFiring = true;
                    // Для напівавтоматики (Glock/Ніж) стріляємо одразу при натисканні
                    if (weapons[activeWeaponIndex].type !== 'auto') {
                        attemptFire();
                    }
                }
            });
            document.addEventListener('mouseup', function() {
                isFiring = false;
            });

            // 5. Створення світу
            buildWorld();

            // 6. Створення зброї (візуалізація)
            createWeaponModels();

            // 7. Рендерер
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // Raycaster для стрільби
            raycaster = new THREE.Raycaster();
        }

        function buildWorld() {
            // Підлога
            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            
            // Проста текстура "сітка" кольорами вершин
            const position = floorGeometry.attributes.position;
            const colorsFloor = [];
            const color = new THREE.Color();

            for (let i = 0, l = position.count; i < l; i++) {
                color.setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                colorsFloor.push(color.r, color.g, color.b);
            }
            floorGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorsFloor, 3));

            const floorMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            scene.add(floor);
            objects.push(floor);

            // Будівлі / Стіни
            const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
            // Розміщуємо 50 випадкових будівель
            for (let i = 0; i < 50; i++) {
                const boxMaterial = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff, flatShading: true });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                
                // Випадкова позиція
                box.position.x = Math.floor(Math.random() * 20 - 10) * 20;
                box.position.y = 10; // Половина висоти, щоб стояв на землі
                box.position.z = Math.floor(Math.random() * 20 - 10) * 20;

                // Не ставити на старті (0,0,0)
                if (Math.abs(box.position.x) < 20 && Math.abs(box.position.z) < 20) continue;

                scene.add(box);
                objects.push(box);
                walls.push(box); // Додаємо в список для фізичної колізії
            }
        }

        function createWeaponModels() {
            weaponMeshGroup = new THREE.Group();
            camera.add(weaponMeshGroup); // Прив'язуємо зброю до камери

            // Позиція зброї на екрані
            weaponMeshGroup.position.set(0.5, -0.5, -1);

            // Моделі для кожної зброї (прості форми)
            
            // 1. AK-47 (Довгий прямокутник + магазин)
            const akGroup = new THREE.Group();
            const akBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1), new THREE.MeshLambertMaterial({ color: 0x5D4037 }));
            const akBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 0.4), new THREE.MeshLambertMaterial({ color: 0x111111 }));
            akBarrel.position.z = -0.6;
            const akMag = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.1), new THREE.MeshLambertMaterial({ color: 0x222222 }));
            akMag.position.set(0, -0.1, -0.2);
            akMag.rotation.x = 0.3;
            
            akGroup.add(akBody, akBarrel, akMag);
            akGroup.userData = { id: 0 };
            weaponMeshGroup.add(akGroup);

            // 2. Glock (Короткий чорний блок)
            const glockGroup = new THREE.Group();
            const glockBody = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.4), new THREE.MeshLambertMaterial({ color: 0x111111 }));
            glockGroup.add(glockBody);
            glockGroup.visible = false;
            glockGroup.userData = { id: 1 };
            weaponMeshGroup.add(glockGroup);

            // 3. Ніж (Плоский срібний блок)
            const knifeGroup = new THREE.Group();
            const knifeBlade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.1, 0.5), new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.8, roughness: 0.2 }));
            knifeBlade.position.z = -0.2;
            const knifeHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.3), new THREE.MeshLambertMaterial({ color: 0x330000 }));
            knifeHandle.position.z = 0.2;
            
            knifeGroup.add(knifeBlade, knifeHandle);
            knifeGroup.rotation.x = 1.5; // Тримаємо як ніж
            knifeGroup.rotation.y = -0.5;
            knifeGroup.position.set(0.2, -0.2, 0); // Трохи ближче
            knifeGroup.visible = false;
            knifeGroup.userData = { id: 2 };
            weaponMeshGroup.add(knifeGroup);
        }

        function switchWeapon(index) {
            if (index < 0 || index >= weapons.length) return;
            activeWeaponIndex = index;

            // Оновлюємо UI
            document.getElementById('weapon-name').innerText = weapons[index].name;

            // Оновлюємо модель
            weaponMeshGroup.children.forEach(child => {
                child.visible = (child.userData.id === index);
            });
        }

        // --- Логіка стрільби ---
        function attemptFire() {
            const now = performance.now();
            const weapon = weapons[activeWeaponIndex];

            if (now - lastFireTime > weapon.rate) {
                fireWeapon(weapon);
                lastFireTime = now;
            }
        }

        function fireWeapon(weapon) {
            // 1. Анімація віддачі
            const currentWeaponMesh = weaponMeshGroup.children.find(c => c.userData.id === activeWeaponIndex);
            if(currentWeaponMesh) {
                currentWeaponMesh.position.z += weapon.recoil; // Відштовхнути назад
                
                // Ніж має анімацію удару
                if (weapon.type === 'melee') {
                     currentWeaponMesh.rotation.x -= 0.5;
                     setTimeout(() => currentWeaponMesh.rotation.x += 0.5, 100);
                }
            }

            // 2. Звук
            playShootSound(weapon.type);

            // 3. Raycast (логіка влучання)
            if (weapon.type !== 'melee') {
                raycaster.setFromCamera( new THREE.Vector2(0,0), camera ); // Центр екрану
                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    // Ефект влучання (маленька сфера)
                    createHitEffect(hit.point);
                    
                    // Тут можна додати логіку пошкодження ворогів у майбутньому
                    if (hit.object.geometry.type === 'BoxGeometry') {
                        // Зміна кольору блоку при влучанні
                        hit.object.material.color.setHex(Math.random() * 0xffffff);
                    }
                }
            }
        }

        function createHitEffect(position) {
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(position);
            scene.add(mesh);

            // Видалити через 500мс
            setTimeout(() => {
                scene.remove(mesh);
                geom.dispose();
                mat.dispose();
            }, 500);
        }

        // --- Синтезатор звуків (Web Audio API) ---
        function playShootSound(type) {
            if (audioCtx.state === 'suspended') return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'melee') {
                // Звук "свист"
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else {
                // Звук пострілу (шум)
                const bufferSize = audioCtx.sampleRate * 0.1; // 0.1 секунди
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                // Фільтр частот
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (type === 'auto' ? 0.1 : 0.2));
                
                noise.start();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Перевірка колізій гравця ---
        function checkCollision(position) {
            const playerRadius = 2; // Радіус гравця (приблизний)
            
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                // Отримуємо межі стіни (AABB)
                const bbox = new THREE.Box3().setFromObject(wall);
                
                // Перевірка, чи точка всередині box (з урахуванням розміру гравця)
                if (position.x > bbox.min.x - playerRadius && position.x < bbox.max.x + playerRadius &&
                    position.z > bbox.min.z - playerRadius && position.z < bbox.max.z + playerRadius) {
                    return true;
                }
            }
            return false;
        }

        // --- Головний цикл гри ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true) {
                const delta = (time - prevTime) / 1000;

                // 1. Оновлення швидкості (інерція)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; // Гравітація

                // 2. Обчислення напрямку
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Нормалізація для діагонального руху

                // 3. Застосування швидкості
                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                // 4. Обробка колізій (передбачення руху)
                controls.moveRight(-velocity.x * delta);
                if (checkCollision(controls.getObject().position)) {
                    controls.moveRight(velocity.x * delta); // Відкат
                    velocity.x = 0;
                }

                controls.moveForward(-velocity.z * delta);
                if (checkCollision(controls.getObject().position)) {
                    controls.moveForward(velocity.z * delta); // Відкат
                    velocity.z = 0;
                }

                // 5. Рух по Y (стрибки)
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 10) {
                    velocity.y = 0;
                    controls.getObject().position.y = 10;
                    canJump = true;
                }

                // 6. Логіка автоматичної зброї
                if (isFiring && weapons[activeWeaponIndex].type === 'auto') {
                    attemptFire();
                }

                // 7. Повернення зброї після віддачі (Smooth Lerp)
                const currentWeaponMesh = weaponMeshGroup.children.find(c => c.userData.id === activeWeaponIndex);
                if (currentWeaponMesh) {
                    // Повертаємо Z до початкового стану (-1 для всієї групи, але локально деталі можуть бути зміщені)
                    // Тут ми змінюємо локальну позицію mesh всередині weaponMeshGroup, але простіше контролювати позицію групи
                    // Але в цій реалізації ми рухали 'currentWeaponMesh'. Початкова Z різна для зброї.
                    
                    // Спрощена логіка: якщо це ніж, інша база, якщо пістолет - інша.
                    // Для простоти, ми просто плавно зменшуємо зміщення, яке додали.
                    if (weapons[activeWeaponIndex].type !== 'melee') {
                        if (currentWeaponMesh.position.z > 0) {
                             currentWeaponMesh.position.z -= delta * 1; 
                             if (currentWeaponMesh.position.z < 0) currentWeaponMesh.position.z = 0;
                        }
                    }
                }
            }

            prevTime = time;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
