<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTRABOLT FPS: TOTAL WAR</title>
    <style>
        :root {
            --primary: #00ffcc;
            --accent: #ff0055;
            --bg: #0a0a0c;
            --panel: rgba(20, 20, 25, 0.95);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: var(--bg);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }
        canvas { display: block; }

        /* UI LAYERS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        .interactive { pointer-events: all; }

        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 30px; height: 30px;
            transform: translate(-50%, -50%);
            display: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: var(--primary);
        }
        #crosshair::before { top: 14px; left: 0; width: 30px; height: 2px; }
        #crosshair::after { left: 14px; top: 0; width: 2px; height: 30px; }

        /* HUD */
        #hud {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 20px; box-sizing: border-box;
            display: none; justify-content: space-between; align-items: flex-end;
        }
        .stats-left, .stats-right {
            background: var(--panel); padding: 15px 25px;
            border-top: 3px solid var(--primary);
            clip-path: polygon(0 0, 90% 0, 100% 100%, 0% 100%);
        }
        .stats-right {
            clip-path: polygon(10% 0, 100% 0, 100% 100%, 0% 100%);
            text-align: right;
        }
        .stat-label { font-size: 12px; color: #888; text-transform: uppercase; }
        .stat-value { font-size: 32px; font-weight: 800; letter-spacing: 2px; }

        /* MENU SYSTEM */
        #menu-container {
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; background: radial-gradient(circle, #1a1a2e 0%, #0a0a0c 100%);
            pointer-events: all;
        }
        .main-title {
            font-size: 80px; font-weight: 900; color: var(--primary);
            text-shadow: 0 0 20px rgba(0,255,204,0.5); margin-bottom: 50px;
        }
        .menu-nav { display: flex; gap: 20px; margin-bottom: 30px; }
        .btn {
            background: transparent; border: 2px solid var(--primary);
            color: var(--primary); padding: 15px 40px; font-size: 18px;
            font-weight: bold; cursor: pointer; transition: 0.3s;
            text-transform: uppercase;
        }
        .btn:hover { background: var(--primary); color: #000; box-shadow: 0 0 15px var(--primary); }
        .btn.active { background: var(--primary); color: #000; }

        /* WINDOWS */
        .window {
            width: 80%; height: 60%; background: var(--panel);
            border: 1px solid var(--primary); display: none;
            padding: 30px; box-sizing: border-box; overflow-y: auto;
        }
        .market-grid, .inv-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }
        .item-card {
            background: rgba(255,255,255,0.05); padding: 20px;
            border: 1px solid #333; transition: 0.2s;
        }
        .item-card:hover { border-color: var(--primary); }
        .item-card h3 { margin: 0 0 10px 0; color: var(--primary); }
        .price { font-size: 20px; color: #fbff00; margin-bottom: 15px; }

        /* NOTIFICATIONS */
        #notif {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .notif-msg {
            background: var(--panel); border-right: 5px solid var(--accent);
            padding: 10px 20px; animation: slideIn 0.3s forwards;
        }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }

        #death-screen {
            display: none; background: rgba(100,0,0,0.8);
            justify-content: center; align-items: center; flex-direction: column;
        }
    </style>
</head>
<body>

<div id="crosshair" class="overlay"></div>

<div id="hud" class="overlay">
    <div class="stats-left">
        <div class="stat-label">Health</div>
        <div id="hp-val" class="stat-value">100</div>
        <div class="stat-label" style="margin-top:5px">Currency</div>
        <div id="money-val" class="stat-value" style="color:#fbff00; font-size:20px">$5000</div>
    </div>
    <div class="stats-right">
        <div class="stat-label">Weapon</div>
        <div id="weapon-name" class="stat-value" style="font-size:24px">AK-47</div>
        <div class="stat-label">Ammo</div>
        <div id="ammo-val" class="stat-value">30 / ∞</div>
    </div>
</div>

<div id="menu-container" class="overlay interactive">
    <div class="main-title">ULTRABOLT</div>
    <div class="menu-nav">
        <button class="btn active" onclick="showTab('main')">Home</button>
        <button class="btn" onclick="showTab('market')">Market</button>
        <button class="btn" onclick="showTab('inv')">Inventory</button>
        <button class="btn" onclick="showTab('settings')">Settings</button>
    </div>

    <div id="tab-main" style="display: block; text-align: center;">
        <button class="btn" style="font-size: 30px; padding: 20px 80px;" onclick="startGame()">DEPLOY TO ZONE</button>
        <p style="color:#888; margin-top:20px;">Eliminate hostile bots. Survive waves. Earn credits.</p>
    </div>

    <div id="tab-market" class="window">
        <h2>BLACK MARKET</h2>
        <div class="market-grid" id="market-list"></div>
    </div>

    <div id="tab-inv" class="window">
        <h2>YOUR ARMORY</h2>
        <div class="inv-grid" id="inv-list"></div>
    </div>

    <div id="tab-settings" class="window">
        <h2>SYSTEM SETTINGS</h2>
        <div style="margin-top:20px">
            <label>Sensitivity</label><br>
            <input type="range" id="sens" min="1" max="100" value="50">
        </div>
    </div>
</div>

<div id="death-screen" class="overlay interactive">
    <h1 style="font-size:100px; color:white; margin:0">KIA</h1>
    <p style="font-size:24px">You have been neutralized.</p>
    <button class="btn" onclick="location.reload()">Return to HQ</button>
</div>

<div id="notif" class="overlay"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';

/**
 * ============================================================================
 * GLOBAL CONFIGURATION & STATE
 * ============================================================================
 */
const CONFIG = {
    GRAVITY: 30,
    PLAYER_SPEED: 12,
    PLAYER_RUN_SPEED: 20,
    JUMP_FORCE: 12,
    BOT_SPAWN_RATE: 5000,
    MAP_SIZE: 500,
    WAVE_INCREASE: 1.2
};

let gameActive = false;
let money = 2500;
let health = 100;
let kills = 0;
let wave = 1;

let inventory = ["weapon_ak47", "weapon_glock", "weapon_knife"];
let activeWeaponSlot = "weapon_ak47";

const WEAPONS_DATA = {
    "weapon_ak47": {
        name: "AK-47",
        type: "auto",
        damage: 34,
        fireRate: 100,
        recoil: 0.04,
        spread: 0.02,
        price: 2700,
        ammo: 30,
        color: 0x4a3728
    },
    "weapon_glock": {
        name: "Glock-18",
        type: "semi",
        damage: 18,
        fireRate: 200,
        recoil: 0.02,
        spread: 0.01,
        price: 500,
        ammo: 17,
        color: 0x222222
    },
    "weapon_knife": {
        name: "Tactical Knife",
        type: "melee",
        damage: 100,
        fireRate: 500,
        recoil: 0,
        spread: 0,
        price: 0,
        ammo: 0,
        color: 0x888888
    }
};

/**
 * ============================================================================
 * ENGINE CORE
 * ============================================================================
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.FogExp2(0x020205, 0.015);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const clock = new THREE.Clock();
const raycaster = new THREE.Raycaster();

// Lights
const ambientLight = new THREE.AmbientLight(0x404050, 0.5);
scene.add(ambientLight);

const sun = new THREE.DirectionalLight(0xffffff, 1.0);
sun.position.set(100, 200, 100);
sun.castShadow = true;
sun.shadow.camera.left = -300;
sun.shadow.camera.right = 300;
sun.shadow.camera.top = 300;
sun.shadow.camera.bottom = -300;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
scene.add(sun);

/**
 * ============================================================================
 * PHYSICS & COLLISION
 * ============================================================================
 */
const physicsObjects = [];
const worldBounds = new THREE.Box3(
    new THREE.Vector3(-CONFIG.MAP_SIZE/2, -10, -CONFIG.MAP_SIZE/2),
    new THREE.Vector3(CONFIG.MAP_SIZE/2, 500, CONFIG.MAP_SIZE/2)
);

function checkCollision(position, radius) {
    for (let obj of physicsObjects) {
        if (obj.isBox) {
            const box = new THREE.Box3().setFromObject(obj);
            const closestPoint = new THREE.Vector3();
            box.clampPoint(position, closestPoint);
            const distance = position.distanceTo(closestPoint);
            if (distance < radius) {
                const diff = new THREE.Vector3().subVectors(position, closestPoint).normalize();
                position.add(diff.multiplyScalar(radius - distance));
                return true;
            }
        }
    }
    return false;
}

/**
 * ============================================================================
 * MAP GENERATOR
 * ============================================================================
 */
function createProceduralMap() {
    // Ground
    const groundGeo = new THREE.PlaneGeometry(CONFIG.MAP_SIZE * 2, CONFIG.MAP_SIZE * 2);
    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x15151b,
        roughness: 0.9,
        metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Grid
    const grid = new THREE.GridHelper(CONFIG.MAP_SIZE * 2, 100, 0x00ffcc, 0x111111);
    grid.position.y = 0.05;
    scene.add(grid);

    // Buildings
    for (let i = 0; i < 150; i++) {
        const h = 10 + Math.random() * 50;
        const w = 10 + Math.random() * 20;
        const d = 10 + Math.random() * 20;

        const geo = new THREE.BoxGeometry(w, h, d);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x111111 + (Math.random() * 0x222222),
            roughness: 0.7
        });
        const b = new THREE.Mesh(geo, mat);
        
        let px, pz;
        do {
            px = (Math.random() - 0.5) * CONFIG.MAP_SIZE;
            pz = (Math.random() - 0.5) * CONFIG.MAP_SIZE;
        } while(Math.abs(px) < 20 && Math.abs(pz) < 20); // Keep spawn clear

        b.position.set(px, h/2, pz);
        b.castShadow = true;
        b.receiveShadow = true;
        b.isBox = true;
        scene.add(b);
        physicsObjects.push(b);

        // Windows / Decals
        if(Math.random() > 0.5) {
            const winGeo = new THREE.PlaneGeometry(w * 0.8, h * 0.8);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
            const win = new THREE.Mesh(winGeo, winMat);
            win.position.set(0, 0, d/2 + 0.1);
            b.add(win);
        }
    }

    // Outer Walls
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x050505 });
    const wallH = 100;
    const perimeter = [
        { size: [CONFIG.MAP_SIZE, wallH, 10], pos: [0, wallH/2, CONFIG.MAP_SIZE/2] },
        { size: [CONFIG.MAP_SIZE, wallH, 10], pos: [0, wallH/2, -CONFIG.MAP_SIZE/2] },
        { size: [10, wallH, CONFIG.MAP_SIZE], pos: [CONFIG.MAP_SIZE/2, wallH/2, 0] },
        { size: [10, wallH, CONFIG.MAP_SIZE], pos: [-CONFIG.MAP_SIZE/2, wallH/2, 0] }
    ];

    perimeter.forEach(p => {
        const g = new THREE.BoxGeometry(...p.size);
        const m = new THREE.Mesh(g, wallMat);
        m.position.set(...p.pos);
        m.isBox = true;
        scene.add(m);
        physicsObjects.push(m);
    });
}
createProceduralMap();

/**
 * ============================================================================
 * PLAYER SYSTEM
 * ============================================================================
 */
const player = {
    velocity: new THREE.Vector3(),
    onGround: false,
    height: 1.8,
    radius: 0.6,
    input: { w:false, a:false, s:false, d:false, shift:false, space:false, mousedown:false },
    recoilY: 0,
    swayTime: 0
};

const weaponGroup = new THREE.Group();
camera.add(weaponGroup);
scene.add(camera);

function setupPlayerInput() {
    window.addEventListener('keydown', (e) => {
        const k = e.code;
        if(k === 'KeyW') player.input.w = true;
        if(k === 'KeyA') player.input.a = true;
        if(k === 'KeyS') player.input.s = true;
        if(k === 'KeyD') player.input.d = true;
        if(k === 'ShiftLeft') player.input.shift = true;
        if(k === 'Space') player.input.space = true;
        if(k === 'Digit1') equipWeapon("weapon_ak47");
        if(k === 'Digit2') equipWeapon("weapon_glock");
        if(k === 'Digit3') equipWeapon("weapon_knife");
    });
    window.addEventListener('keyup', (e) => {
        const k = e.code;
        if(k === 'KeyW') player.input.w = false;
        if(k === 'KeyA') player.input.a = false;
        if(k === 'KeyS') player.input.s = false;
        if(k === 'KeyD') player.input.d = false;
        if(k === 'ShiftLeft') player.input.shift = false;
        if(k === 'Space') player.input.space = false;
    });
    window.addEventListener('mousedown', () => { if(gameActive) player.input.mousedown = true; if(!gameActive && !document.pointerLockElement && health > 0) {} });
    window.addEventListener('mouseup', () => player.input.mousedown = false);
    window.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement) {
            const sens = document.getElementById('sens').value / 25000;
            camera.rotation.y -= e.movementX * sens * 10;
            camera.rotation.x -= e.movementY * sens * 10;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }
    });
}
setupPlayerInput();

/**
 * ============================================================================
 * WEAPON ENGINE
 * ============================================================================
 */
let currentWeaponModel = null;
let lastFireTime = 0;

function buildWeaponModel(weaponId) {
    if(currentWeaponModel) weaponGroup.remove(currentWeaponModel);
    const wData = WEAPONS_DATA[weaponId];
    const group = new THREE.Group();

    // Procedural modeling based on weapon type
    if(weaponId === "weapon_ak47") {
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.6), new THREE.MeshStandardMaterial({color:0x222222}));
        const stock = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.3), new THREE.MeshStandardMaterial({color:0x4a3728}));
        stock.position.z = 0.4;
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), new THREE.MeshStandardMaterial({color:0x111111}));
        barrel.rotation.x = Math.PI/2; barrel.position.z = -0.5;
        const mag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.1), new THREE.MeshStandardMaterial({color:0x111111}));
        mag.position.set(0, -0.15, -0.1); mag.rotation.x = 0.3;
        group.add(body, stock, barrel, mag);
    } else if(weaponId === "weapon_glock") {
        const slide = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.3), new THREE.MeshStandardMaterial({color:0x111111}));
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.08), new THREE.MeshStandardMaterial({color:0x222222}));
        grip.position.set(0, -0.1, 0.08); grip.rotation.x = 0.2;
        group.add(slide, grip);
    } else {
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.06, 0.3), new THREE.MeshStandardMaterial({color:0x888888, metalness:1, roughness:0.1}));
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.15), new THREE.MeshStandardMaterial({color:0x111111}));
        handle.position.z = 0.2;
        group.add(blade, handle);
    }

    // Hands
    const armMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c });
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), armMat);
    armL.position.set(-0.3, -0.2, 0.2);
    const armR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.6), armMat);
    armR.position.set(0.3, -0.2, 0.2);
    group.add(armL, armR);

    group.position.set(0.3, -0.4, -0.5);
    weaponGroup.add(group);
    currentWeaponModel = group;
}

function equipWeapon(id) {
    if(!inventory.includes(id)) return;
    activeWeaponSlot = id;
    buildWeaponModel(id);
    document.getElementById("weapon-name").innerText = WEAPONS_DATA[id].name;
    document.getElementById("ammo-val").innerText = WEAPONS_DATA[id].ammo > 0 ? WEAPONS_DATA[id].ammo + " / ∞" : "--";
}

function shoot() {
    const w = WEAPONS_DATA[activeWeaponSlot];
    const now = Date.now();
    if(now - lastFireTime < w.fireRate) return;
    lastFireTime = now;

    // Recoil
    player.recoilY += w.recoil;
    camera.rotation.x += w.recoil;
    currentWeaponModel.position.z += 0.1;

    // Raycast for Hit
    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
    const intersects = raycaster.intersectObjects(bots.map(b => b.mesh), true);
    
    if(intersects.length > 0) {
        const hit = intersects[0];
        const bot = bots.find(b => b.mesh === hit.object || b.mesh.children.includes(hit.object));
        if(bot) {
            bot.takeDamage(w.damage);
            createImpact(hit.point, 0xff0000);
        } else {
            createImpact(hit.point, 0xcccccc);
        }
    }

    // Muzzle Flash
    const flash = new THREE.PointLight(0xffaa00, 2, 5);
    flash.position.set(0.3, -0.3, -1);
    camera.add(flash);
    setTimeout(() => camera.remove(flash), 50);

    // Tracer
    createTracer();
}

function createImpact(pos, color) {
    const geo = new THREE.SphereGeometry(0.1);
    const mat = new THREE.MeshBasicMaterial({color: color});
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(pos);
    scene.add(p);
    setTimeout(() => scene.add(p), 100); // reuse/removal logic simplified for speed
    setTimeout(() => scene.remove(p), 2000);
}

function createTracer() {
    const points = [];
    points.push(new THREE.Vector3(0.3, -0.4, -0.8).applyMatrix4(camera.matrixWorld));
    
    const end = new THREE.Vector3(0,0,-100).applyMatrix4(camera.matrixWorld);
    points.push(end);

    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({color: 0xffff00, transparent:true, opacity:0.5});
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    setTimeout(() => scene.remove(line), 30);
}

/**
 * ============================================================================
 * BOT AI SYSTEM
 * ============================================================================
 */
const bots = [];
class Bot {
    constructor() {
        this.hp = 100;
        this.speed = 4 + Math.random() * 4;
        this.state = 'chase';
        
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1, 4, 8), new THREE.MeshStandardMaterial({color:0xff3333}));
        body.position.y = 1;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color:0xffaaaa}));
        head.position.y = 2;
        group.add(body, head);
        
        let px, pz;
        do {
            px = (Math.random() - 0.5) * CONFIG.MAP_SIZE;
            pz = (Math.random() - 0.5) * CONFIG.MAP_SIZE;
        } while(new THREE.Vector3(px, 1, pz).distanceTo(camera.position) < 30);

        group.position.set(px, 0, pz);
        scene.add(group);
        this.mesh = group;
        this.mesh.castShadow = true;
    }

    update(dt) {
        if(this.hp <= 0) return;

        const dist = this.mesh.position.distanceTo(camera.position);
        if(dist < 2.0) {
            // Attack player
            health -= 0.5;
            document.getElementById("hp-val").innerText = Math.ceil(health);
            if(health <= 0) gameOver();
        }

        // Move towards player
        const dir = new THREE.Vector3().subVectors(camera.position, this.mesh.position);
        dir.y = 0;
        dir.normalize();
        this.mesh.position.add(dir.multiplyScalar(this.speed * dt));
        this.mesh.lookAt(camera.position.x, 0, camera.position.z);
    }

    takeDamage(amt) {
        this.hp -= amt;
        this.mesh.children[0].material.color.set(0xffffff);
        setTimeout(() => this.mesh.children[0].material.color.set(0xff3333), 100);
        if(this.hp <= 0) {
            scene.remove(this.mesh);
            kills++;
            money += 300;
            updateUI();
            addNotif("Hostile Neutralized +$300");
        }
    }
}

function spawnWave() {
    const count = Math.floor(5 * wave);
    for(let i=0; i<count; i++) {
        bots.push(new Bot());
    }
    addNotif("WAVE " + wave + " INBOUND");
    wave++;
}

/**
 * ============================================================================
 * UI & ECONOMY
 * ============================================================================
 */
function showTab(tab) {
    document.querySelectorAll('.window').forEach(w => w.style.display = 'none');
    document.getElementById('tab-main').style.display = 'none';
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    
    if(tab === 'main') {
        document.getElementById('tab-main').style.display = 'block';
    } else {
        document.getElementById('tab-' + tab).style.display = 'block';
    }
}

function updateUI() {
    document.getElementById("money-val").innerText = "$" + money;
    renderMarket();
    renderInventory();
}

function renderMarket() {
    const container = document.getElementById("market-list");
    container.innerHTML = "";
    for(let id in WEAPONS_DATA) {
        if(inventory.includes(id)) continue;
        const w = WEAPONS_DATA[id];
        const card = document.createElement('div');
        card.className = "item-card";
        card.innerHTML = `
            <h3>${w.name}</h3>
            <div class="price">$${w.price}</div>
            <button class="btn" onclick="buyItem('${id}')">Purchase</button>
        `;
        container.appendChild(card);
    }
}

window.buyItem = function(id) {
    const w = WEAPONS_DATA[id];
    if(money >= w.price) {
        money -= w.price;
        inventory.push(id);
        addNotif("Obtained " + w.name);
        updateUI();
    } else {
        addNotif("Insufficient Credits");
    }
};

function renderInventory() {
    const container = document.getElementById("inv-list");
    container.innerHTML = "";
    inventory.forEach(id => {
        const w = WEAPONS_DATA[id];
        const card = document.createElement('div');
        card.className = "item-card";
        card.innerHTML = `
            <h3>${w.name}</h3>
            <button class="btn ${activeWeaponSlot === id ? 'active' : ''}" onclick="equipWeapon('${id}')">Equip</button>
        `;
        container.appendChild(card);
    });
}

function addNotif(msg) {
    const n = document.createElement('div');
    n.className = "notif-msg";
    n.innerText = msg;
    document.getElementById("notif").appendChild(n);
    setTimeout(() => n.remove(), 3000);
}

/**
 * ============================================================================
 * GAME LOOP
 * ============================================================================
 */
function startGame() {
    document.getElementById("menu-container").style.display = "none";
    document.getElementById("hud").style.display = "flex";
    document.getElementById("crosshair").style.display = "block";
    document.body.requestPointerLock();
    gameActive = true;
    equipWeapon(activeWeaponSlot);
    setInterval(spawnWave, CONFIG.BOT_SPAWN_RATE);
}

function gameOver() {
    gameActive = false;
    document.exitPointerLock();
    document.getElementById("death-screen").style.display = "flex";
}

function update(dt) {
    if(!gameActive) return;

    // Movement
    const speed = player.input.shift ? CONFIG.PLAYER_RUN_SPEED : CONFIG.PLAYER_SPEED;
    direction.z = Number(player.input.s) - Number(player.input.w);
    direction.x = Number(player.input.d) - Number(player.input.a);
    direction.normalize();

    if (player.input.w || player.input.s) player.velocity.z -= direction.z * speed * dt;
    if (player.input.a || player.input.d) player.velocity.x -= direction.x * speed * dt;

    // Gravity & Jump
    player.velocity.y -= CONFIG.GRAVITY * dt;
    if(player.onGround && player.input.space) {
        player.velocity.y = CONFIG.JUMP_FORCE;
        player.onGround = false;
    }

    // Apply Velocity
    const nextPos = camera.position.clone();
    nextPos.x += player.velocity.x * dt;
    nextPos.z += player.velocity.z * dt;
    
    // Friction
    player.velocity.x *= 0.85;
    player.velocity.z *= 0.85;

    // Collision Detection
    camera.position.y += player.velocity.y * dt;
    if(camera.position.y < PLAYER_HEIGHT) {
        camera.position.y = PLAYER_HEIGHT;
        player.velocity.y = 0;
        player.onGround = true;
    }
    
    checkCollision(camera.position, player.radius);

    // Shooting
    if(player.input.mousedown) {
        shoot();
    }

    // Weapon Animation (Sway/Reset)
    player.recoilY *= 0.9;
    currentWeaponModel.position.z = THREE.MathUtils.lerp(currentWeaponModel.position.z, -0.5, 0.1);
    
    player.swayTime += dt * (player.input.w || player.input.s ? 10 : 2);
    currentWeaponModel.position.y = -0.4 + Math.sin(player.swayTime) * 0.01;
    currentWeaponModel.position.x = 0.3 + Math.cos(player.swayTime * 0.5) * 0.01;

    // Update Bots
    for(let i = bots.length - 1; i >= 0; i--) {
        if(bots[i].hp <= 0) {
            bots.splice(i, 1);
            continue;
        }
        bots[i].update(dt);
    }
}

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    update(dt);
    renderer.render(scene, camera);
}

// Final setup
updateUI();
const PLAYER_HEIGHT = 1.8;
camera.position.set(0, PLAYER_HEIGHT, 0);

</script>
</body>
</html>
